---
layout: post
title: HashMap源码分析
date: 2023-02-27 19:20:23 +0900
category: JavaMap
---
# HashMap源码分析

### HashMap UML类图

> UML 全拼 Unified Modeling Language 统一建模语言

![alt text](/public/img/hashmap.png)

* HashMap继承AbstractMap，AbstractMap实现了Map接口的抽象方法，没有实现默认方法
* HashMap实现Cloneable接口,表明此类可以被克隆clone,常见于原型模式
* HashMap实现Serializable接口，表明可以序列化
* HashMap重写的AbstractMap中大部分方法，只有equals clone等方法没有重写
* Map接口中涉及的BiConsumer接口。此类Consumer相关的接口属于功能接口，区别在于传参和返回值的不同

> 小知识点：在java中的<<运算符，都是2的多少次幂，比如3<<4 表示 2的4次幂 再乘 3
> 用二进制的算法就是 把3转成二进制，左移4位，也就是在后面加4个零
> ">>" 表示向右移动

### 源码分析
#### putVal方法
* tab[i = (n-1) & hash] 中括号内的部分是计算hash存在的位置，避免hash冲突，使元素均匀分布。 n是tab数组的长度，转换为二进制后，前面的都是0，与hash进行与操作最大值也就是n-1本身，所以不会越界
* 当put的key存在hash冲突时，新增的node会放到链表中，遍历node链表，把新node放到最后
* 当map的size大于临界值12时(数组+链表总大小)，会进行resize，容量扩容为原来的2倍，临界值也变为原来的2倍
> 当HashMap的容量不足时，将原来的数组扩容为两倍，并将原来的元素重新分配到新的数组中。
> 具体的步骤如下：
> * 遍历原来的数组，对每个位置上的元素进行处理
> * 如果该位置上只有一个节点，直接计算它在新数组中的位置，并放入新数组中
> * 如果该位置上是一棵红黑树，将红黑树拆分为两棵子树，并分别放入新数组中
> * 如果该位置上是一个链表，将链表拆分为两个子链表，并分别放入新数组中
> * 拆分链表和红黑树的方法是利用了e.hash & oldCap == 0这个条件，如果成立，则说明该节点在新数组中的位置不变；如果不成立，则说明该节点在新数组中的位置需要加上oldCap。这样可以避免重新计算hash值，并保持相对顺序不变。 (二进制计算，因为容量是16[二进制是10000]的倍数，e.hash & oldCap == 0 时，扩容后 (e.hash & (oldCap - 1)) 等于 (e.hash & (newCap - 1))
